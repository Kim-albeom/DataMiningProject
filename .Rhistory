ifelse(smoothness_mean <= 0.12, 3, 4))),
compactness_mean_score = ifelse(compactness_mean <= 0.06, 1,
ifelse(compactness_mean <= 0.09, 2,
ifelse(compactness_mean <= 16, 3, 4))),
symmetry_mean_score = ifelse(symmetry_mean <= 0.16, 1,
ifelse(symmetry_mean <= 0.18, 2,
ifelse(symmetry_mean <= 0.20, 3, 4))),
radius_se_score = ifelse(radius_se <= 0.22, 1,
ifelse(radius_se <= 0.33, 2,
ifelse(radius_se <= 0.44, 3, 4))),
texture_se_score = ifelse(texture_se <= 0.90, 1,
ifelse(texture_se <= 1.20, 2,
ifelse(texture_se <= 1.50, 3, 4))),
fractal_dimension_se_score = ifelse(fractal_dimension_se <= 0.002, 1,
ifelse(fractal_dimension_se <= 0.003, 2,
ifelse(fractal_dimension_se <= 0.004, 3, 4))))
# _score로 끝나는 모든 변수들의 합을 계산하여 score라는 새로운 열을 생성
score_01_vars <- grep("_score$", names(score_01_data), value = TRUE)
# 각 변수에 대해 주어진 범위에 따라 클래스와 점수를 부여
score_01_data <- selected_data %>%
mutate(radius_mean_score = ifelse(radius_mean <= 10, 1,
ifelse(radius_mean <= 13, 2,
ifelse(radius_mean <= 16, 3, 4))),
texture_mean_score = ifelse(texture_mean <= 16, 1,
ifelse(texture_mean <= 19, 2,
ifelse(texture_mean <= 22, 20.35, 27.7))),
smoothness_mean_score = ifelse(smoothness_mean <= 0.08, 1,
ifelse(smoothness_mean <= 0.09, 2,
ifelse(smoothness_mean <= 0.12, 3, 4))),
compactness_mean_score = ifelse(compactness_mean <= 0.06, 1,
ifelse(compactness_mean <= 0.09, 2,
ifelse(compactness_mean <= 16, 3, 4))),
symmetry_mean_score = ifelse(symmetry_mean <= 0.16, 1,
ifelse(symmetry_mean <= 0.18, 2,
ifelse(symmetry_mean <= 0.20, 3, 4))),
radius_se_score = ifelse(radius_se <= 0.22, 1,
ifelse(radius_se <= 0.33, 2,
ifelse(radius_se <= 0.44, 3, 4))),
texture_se_score = ifelse(texture_se <= 0.90, 1,
ifelse(texture_se <= 1.20, 2,
ifelse(texture_se <= 1.50, 3, 4))),
fractal_dimension_se_score = ifelse(fractal_dimension_se <= 0.002, 1,
ifelse(fractal_dimension_se <= 0.003, 2,
ifelse(fractal_dimension_se <= 0.004, 3, 4))))
# _score로 끝나는 모든 변수들의 합을 계산하여 score라는 새로운 열을 생성
score_01_vars <- grep("_score$", names(score_01_data), value = TRUE)
score_01_data <- score_01_data %>% mutate(score = rowSums(.[score_01_vars]))
group_B <- score_01_data$score[score_01_data$diagnosis == "B"]
group_M <- score_01_data$score[score_01_data$diagnosis == "M"]
# KS 통계량 계산
ks_result_01 <- ks.test(group_B, group_M)
# KS 통계량 출력
print(ks_result_01$statistic)
View(score_1_data)
View(score_01_data)
# 누적 B/M 구성비 분포 그래프 그리기
ggplot() +
stat_ecdf(data = data.frame(score = group_B, group = "B"), aes(score, colour = group)) +
stat_ecdf(data = data.frame(score = group_M, group = "M"), aes(score, colour = group)) +
labs(x = "Score", y = "Cumulative Proportion",
title = "Cumulative Distribution Plot for Score",
subtitle = "Blue: Group B, Red: Group M")
# 'B'와 'M' 진단 그룹의 실제 라벨 생성
actual <- ifelse(score_01_data$diagnosis == "B", 0, 1)
# 예측 객체 생성
pred <- prediction(score_01_data$score, actual)
# ROC 곡선 계산
roc_obj <- performance(pred, "tpr", "fpr")
# AUROC 값 계산
auc_obj <- performance(pred, "auc")
# AUROC 값 출력
print(auc_obj@y.values[[1]])
decision_values = data.frame(cut = roc_obj@alpha.values[[1]],
sensitivity = roc_obj@x.values[[1]],
specificity = roc_obj@y.values[[1]])
optimal_cut = decision_values[which.max(decision_values$sensitivity + decision_values$specificity), "cut"]
optimal_cut
# 각 변수에 대해 주어진 범위에 따라 클래스와 점수를 부여
score_2_data <- selected_data %>%
mutate(radius_mean_score = ifelse(radius_mean <= 10, 9.29,
ifelse(radius_mean <= 13, 12.4,
ifelse(radius_mean <= 16, 14.3, 21.3))),
texture_mean_score = ifelse(texture_mean <= 16, 13.45,
ifelse(texture_mean <= 19, 17.55,
ifelse(texture_mean <= 22, 20.35, 27.7))),
smoothness_mean_score = ifelse(smoothness_mean <= 0.08, 0.0688,
ifelse(smoothness_mean <= 0.09, 0.0898,
ifelse(smoothness_mean <= 0.12, 0.0998, 0.134))),
compactness_mean_score = ifelse(compactness_mean <= 0.06, 0.04125,
ifelse(compactness_mean <= 0.09, 0.07635,
ifelse(compactness_mean <= 16, 0.1098, 0.2085))),
symmetry_mean_score = ifelse(symmetry_mean <= 0.16, 0.14,
ifelse(symmetry_mean <= 0.18, 0.171,
ifelse(symmetry_mean <= 0.20, 0.187, 0.2495))),
radius_se_score = ifelse(radius_se <= 0.22, 0.172,
ifelse(radius_se <= 0.33, 0.274,
ifelse(radius_se <= 0.44, 0.392, 0.989))),
texture_se_score = ifelse(texture_se <= 0.90, 0.608,
ifelse(texture_se <= 1.20, 0.998,
ifelse(texture_se <= 1.50, 1.31, 2.565))),
fractal_dimension_se_score = ifelse(fractal_dimension_se <= 0.002, 0.0015575,
ifelse(fractal_dimension_se <= 0.003, 0.002675,
ifelse(fractal_dimension_se <= 0.004, 0.003815, 0.01715))))
# _score로 끝나는 모든 변수들의 합을 계산하여 score라는 새로운 열을 생성
score_02_vars <- grep("_score$", names(score_02_data), value = TRUE)
# 각 변수에 대해 주어진 범위에 따라 클래스와 점수를 부여
score_02_data <- selected_data %>%
mutate(radius_mean_score = ifelse(radius_mean <= 10, 9.29,
ifelse(radius_mean <= 13, 12.4,
ifelse(radius_mean <= 16, 14.3, 21.3))),
texture_mean_score = ifelse(texture_mean <= 16, 13.45,
ifelse(texture_mean <= 19, 17.55,
ifelse(texture_mean <= 22, 20.35, 27.7))),
smoothness_mean_score = ifelse(smoothness_mean <= 0.08, 0.0688,
ifelse(smoothness_mean <= 0.09, 0.0898,
ifelse(smoothness_mean <= 0.12, 0.0998, 0.134))),
compactness_mean_score = ifelse(compactness_mean <= 0.06, 0.04125,
ifelse(compactness_mean <= 0.09, 0.07635,
ifelse(compactness_mean <= 16, 0.1098, 0.2085))),
symmetry_mean_score = ifelse(symmetry_mean <= 0.16, 0.14,
ifelse(symmetry_mean <= 0.18, 0.171,
ifelse(symmetry_mean <= 0.20, 0.187, 0.2495))),
radius_se_score = ifelse(radius_se <= 0.22, 0.172,
ifelse(radius_se <= 0.33, 0.274,
ifelse(radius_se <= 0.44, 0.392, 0.989))),
texture_se_score = ifelse(texture_se <= 0.90, 0.608,
ifelse(texture_se <= 1.20, 0.998,
ifelse(texture_se <= 1.50, 1.31, 2.565))),
fractal_dimension_se_score = ifelse(fractal_dimension_se <= 0.002, 0.0015575,
ifelse(fractal_dimension_se <= 0.003, 0.002675,
ifelse(fractal_dimension_se <= 0.004, 0.003815, 0.01715))))
# _score로 끝나는 모든 변수들의 합을 계산하여 score라는 새로운 열을 생성
score_02_vars <- grep("_score$", names(score_02_data), value = TRUE)
score_02_data <- score_02_data %>% mutate(score = rowSums(.[score_02_vars]))
group_B <- score_02_data$score[score_02_data$diagnosis == "B"]
group_M <- score_02_data$score[score_02_data$diagnosis == "M"]
# KS 통계량 계산
ks_result_02 <- ks.test(group_B, group_M)
# KS 통계량 출력
print(ks_result_02$statistic)
# 누적 B/M 구성비 분포 그래프 그리기
ggplot() +
stat_ecdf(data = data.frame(score = group_B, group = "B"), aes(score, colour = group)) +
stat_ecdf(data = data.frame(score = group_M, group = "M"), aes(score, colour = group)) +
labs(x = "Score", y = "Cumulative Proportion",
title = "Cumulative Distribution Plot for Score",
subtitle = "Blue: Group B, Red: Group M")
# 'B'와 'M' 진단 그룹의 실제 라벨 생성
actual <- ifelse(score_02_data$diagnosis == "B", 0, 1)
# 예측 객체 생성
pred <- prediction(score_02_data$score, actual)
# ROC 곡선 계산
roc_obj <- performance(pred, "tpr", "fpr")
# AUROC 값 계산
auc_obj <- performance(pred, "auc")
# AUROC 값 출력
print(auc_obj@y.values[[1]])
decision_values = data.frame(cut = roc_obj@alpha.values[[1]],
sensitivity = roc_obj@x.values[[1]],
specificity = roc_obj@y.values[[1]])
optimal_cut = decision_values[which.max(decision_values$sensitivity + decision_values$specificity), "cut"]
View(score_02_data)
View(score_02_data)
# AUROC 값 출력
print(auc_obj@y.values[[1]])
# AUROC 값 출력
print(auc_obj@y.values[[1]])
# 각 변수에 대해 주어진 범위에 따라 클래스와 점수를 부여
score_01_data <- selected_data %>%
mutate(radius_mean_score = ifelse(radius_mean <= 10, 1,
ifelse(radius_mean <= 13, 2,
ifelse(radius_mean <= 16, 3, 4))),
texture_mean_score = ifelse(texture_mean <= 16, 1,
ifelse(texture_mean <= 19, 2,
ifelse(texture_mean <= 22, 20.35, 27.7))),
smoothness_mean_score = ifelse(smoothness_mean <= 0.08, 1,
ifelse(smoothness_mean <= 0.09, 2,
ifelse(smoothness_mean <= 0.12, 3, 4))),
compactness_mean_score = ifelse(compactness_mean <= 0.06, 1,
ifelse(compactness_mean <= 0.09, 2,
ifelse(compactness_mean <= 16, 3, 4))),
symmetry_mean_score = ifelse(symmetry_mean <= 0.16, 1,
ifelse(symmetry_mean <= 0.18, 2,
ifelse(symmetry_mean <= 0.20, 3, 4))),
radius_se_score = ifelse(radius_se <= 0.22, 1,
ifelse(radius_se <= 0.33, 2,
ifelse(radius_se <= 0.44, 3, 4))),
texture_se_score = ifelse(texture_se <= 0.90, 1,
ifelse(texture_se <= 1.20, 2,
ifelse(texture_se <= 1.50, 3, 4))),
fractal_dimension_se_score = ifelse(fractal_dimension_se <= 0.002, 1,
ifelse(fractal_dimension_se <= 0.003, 2,
ifelse(fractal_dimension_se <= 0.004, 3, 4))))
# _score로 끝나는 모든 변수들의 합을 계산하여 score라는 새로운 열을 생성
score_01_vars <- grep("_score$", names(score_01_data), value = TRUE)
score_01_data <- score_01_data %>% mutate(score = rowSums(.[score_01_vars]))
group_B <- score_01_data$score[score_01_data$diagnosis == "B"]
group_M <- score_01_data$score[score_01_data$diagnosis == "M"]
# KS 통계량 계산
ks_result_01 <- ks.test(group_B, group_M)
# KS 통계량 출력
print(ks_result_01$statistic)
# 누적 B/M 구성비 분포 그래프 그리기
ggplot() +
stat_ecdf(data = data.frame(score = group_B, group = "B"), aes(score, colour = group)) +
stat_ecdf(data = data.frame(score = group_M, group = "M"), aes(score, colour = group)) +
labs(x = "Score", y = "Cumulative Proportion",
title = "Cumulative Distribution Plot for Score",
subtitle = "Blue: Group B, Red: Group M")
# 각 변수에 대해 주어진 범위에 따라 클래스와 점수를 부여
score_3_data <- selected_data %>%
mutate(radius_mean_score = ifelse(radius_mean <= 10, 31,
ifelse(radius_mean <= 13, 34,
ifelse(radius_mean <= 16, 37, 40))),
texture_mean_score = ifelse(texture_mean <= 16, 13,
ifelse(texture_mean <= 19, 16,
ifelse(texture_mean <= 22, 19, 22))),
smoothness_mean_score = ifelse(smoothness_mean <= 0.08, 8,
ifelse(smoothness_mean <= 0.09, 9,
ifelse(smoothness_mean <= 0.12, 10, 11))),
compactness_mean_score = ifelse(compactness_mean <= 0.06, 4,
ifelse(compactness_mean <= 0.09, 6,
ifelse(compactness_mean <= 16, 8, 10))),
symmetry_mean_score = ifelse(symmetry_mean <= 0.16, 84,
ifelse(symmetry_mean <= 0.18, 87,
ifelse(symmetry_mean <= 0.20, 90, 93))),
radius_se_score = ifelse(radius_se <= 0.22, 5,
ifelse(radius_se <= 0.33, 6,
ifelse(radius_se <= 0.44, 7, 8))),
texture_se_score = ifelse(texture_se <= 0.90, -4,
ifelse(texture_se <= 1.20, -7,
ifelse(texture_se <= 1.50, -10, -13))),
fractal_dimension_se_score = ifelse(fractal_dimension_se <= 0.002, -4,
ifelse(fractal_dimension_se <= 0.003, -5,
ifelse(fractal_dimension_se <= 0.004, -6, -7))))
# _score로 끝나는 모든 변수들의 합을 계산하여 score라는 새로운 열을 생성
score_03_vars <- grep("_score$", names(score_3_data), value = TRUE)
score_3_data <- score_3_data %>% mutate(score = rowSums(.[score_03_vars]))
group_B <- score_3_data$score[score_3_data$diagnosis == "B"]
group_M <- score_3_data$score[score_3_data$diagnosis == "M"]
# KS 통계량 계산
ks_result_03 <- ks.test(group_B, group_M)
# KS 통계량 출력
print(ks_result_03$statistic)
# 누적 B/M 구성비 분포 그래프 그리기
ggplot() +
stat_ecdf(data = data.frame(score = group_B, group = "B"), aes(score, colour = group)) +
stat_ecdf(data = data.frame(score = group_M, group = "M"), aes(score, colour = group)) +
labs(x = "Score", y = "Cumulative Proportion",
title = "Cumulative Distribution Plot for Score",
subtitle = "Blue: Group B, Red: Group M")
# 누적 B/M 구성비 분포 그래프 그리기
ggplot() +
stat_ecdf(data = data.frame(score = group_B, group = "B"), aes(score, colour = group)) +
stat_ecdf(data = data.frame(score = group_M, group = "M"), aes(score, colour = group)) +
labs(x = "Score", y = "Cumulative Proportion",
title = "Cumulative Distribution Plot for Score",
subtitle = "Blue: Group B, Red: Group M")
# 'B'와 'M' 진단 그룹의 실제 라벨 생성
actual <- ifelse(score_3_data$diagnosis == "B", 0, 1)
# 예측 객체 생성
pred <- prediction(score_3_data$score, actual)
# ROC 곡선 계산
roc_obj <- performance(pred, "tpr", "fpr")
# AUROC 값 계산
auc_obj <- performance(pred, "auc")
# AUROC 값 출력
print(auc_obj@y.values[[1]])
#
decision_values = data.frame(cut = roc_obj@alpha.values[[1]],
sensitivity = roc_obj@x.values[[1]],
specificity = roc_obj@y.values[[1]])
optimal_cut = decision_values[which.max(decision_values$sensitivity + decision_values$specificity), "cut"]
# 최종 변수 리스트
var_list <- c('radius_mean', 'texture_mean', 'smoothness_mean', 'compactness_mean', 'symmetry_mean', 'radius_se', 'texture_se', 'fractal_dimension_se')
# 분포 기반 범주화 및 범주 범위 출력
for (var in var_list) {
# 범주화
breast_cancer_train <- breast_cancer_train %>%
mutate(!!paste0(var, "_cat") := cut(!!sym(var), breaks=quantile(!!sym(var), probs=seq(0, 1, by=0.25)), include.lowest=TRUE))
# 범주 범위 출력
cat(paste("Variable:", var, "\n"))
print(summary(as.factor(breast_cancer_train[[paste0(var, "_cat")]])))
}
# 각 변수에 대해 주어진 범위에 따라 클래스와 점수를 부여
score_03_data <- selected_data %>%
mutate(radius_mean_score = ifelse(radius_mean <= 10, 9.29,
ifelse(radius_mean <= 13, 12.4,
ifelse(radius_mean <= 16, 14.3, 21.3))),
texture_mean_score = ifelse(texture_mean <= 16, 13.45,
ifelse(texture_mean <= 19, 17.55,
ifelse(texture_mean <= 22, 20.35, 27.7))),
smoothness_mean_score = ifelse(smoothness_mean <= 0.08, 0.0688,
ifelse(smoothness_mean <= 0.09, 0.0898,
ifelse(smoothness_mean <= 0.12, 0.0998, 0.134))),
compactness_mean_score = ifelse(compactness_mean <= 0.06, 0.04125,
ifelse(compactness_mean <= 0.09, 0.07635,
ifelse(compactness_mean <= 16, 0.1098, 0.2085))),
symmetry_mean_score = ifelse(symmetry_mean <= 0.16, 0.14,
ifelse(symmetry_mean <= 0.18, 0.171,
ifelse(symmetry_mean <= 0.20, 0.187, 0.2495))),
radius_se_score = ifelse(radius_se <= 0.22, 0.172,
ifelse(radius_se <= 0.33, 0.274,
ifelse(radius_se <= 0.44, 0.392, 0.989))),
texture_se_score = ifelse(texture_se <= 0.90, -0.608,
ifelse(texture_se <= 1.20, -0.998,
ifelse(texture_se <= 1.50, 1.31, -2.565))),
fractal_dimension_se_score = ifelse(fractal_dimension_se <= 0.002, -0.0015575,
ifelse(fractal_dimension_se <= 0.003, -0.002675,
ifelse(fractal_dimension_se <= 0.004, -0.003815, -0.01715))))
# _score로 끝나는 모든 변수들의 합을 계산하여 score라는 새로운 열을 생성
score_03_vars <- grep("_score$", names(score_03_data), value = TRUE)
score_03_data <- score_03_data %>% mutate(score = rowSums(.[score_03_vars]))
group_B <- score_03_data$score[score_03_data$diagnosis == "B"]
group_M <- score_03_data$score[score_03_data$diagnosis == "M"]
# KS 통계량 계산
ks_result_03 <- ks.test(group_B, group_M)
# KS 통계량 출력
print(ks_result_03$statistic)
# 누적 B/M 구성비 분포 그래프 그리기
ggplot() +
stat_ecdf(data = data.frame(score = group_B, group = "B"), aes(score, colour = group)) +
stat_ecdf(data = data.frame(score = group_M, group = "M"), aes(score, colour = group)) +
labs(x = "Score", y = "Cumulative Proportion",
title = "Cumulative Distribution Plot for Score",
subtitle = "Blue: Group B, Red: Group M")
# 'B'와 'M' 진단 그룹의 실제 라벨 생성
actual <- ifelse(score_02_data$diagnosis == "B", 0, 1)
# 예측 객체 생성
pred <- prediction(score_02_data$score, actual)
# ROC 곡선 계산
roc_obj <- performance(pred, "tpr", "fpr")
# AUROC 값 계산
auc_obj <- performance(pred, "auc")
# AUROC 값 출력
print(auc_obj@y.values[[1]])
# 'B'와 'M' 진단 그룹의 실제 라벨 생성
actual <- ifelse(score_03_data$diagnosis == "B", 0, 1)
# 예측 객체 생성
pred <- prediction(score_03_data$score, actual)
# ROC 곡선 계산
roc_obj <- performance(pred, "tpr", "fpr")
# AUROC 값 계산
auc_obj <- performance(pred, "auc")
# AUROC 값 출력
print(auc_obj@y.values[[1]])
# 각 변수에 대해 주어진 범위에 따라 클래스와 점수를 부여
score_03_data <- selected_data %>%
mutate(radius_mean_score = ifelse(radius_mean <= 10, 9.533,
ifelse(radius_mean <= 13, 12.724,
ifelse(radius_mean <= 16, 14.674, 21.858))),
texture_mean_score = ifelse(texture_mean <= 16, 5.844,
ifelse(texture_mean <= 19, 7.625,
ifelse(texture_mean <= 22, 8.842, 12.035))),
smoothness_mean_score = ifelse(smoothness_mean <= 0.08, 5.489,
ifelse(smoothness_mean <= 0.09, 7.165,
ifelse(smoothness_mean <= 0.12, 7.963, 10.692))),
compactness_mean_score = ifelse(compactness_mean <= 0.06, 1.153,
ifelse(compactness_mean <= 0.09, 2.134,
ifelse(compactness_mean <= 16, 3.069, 5.828))),
symmetry_mean_score = ifelse(symmetry_mean <= 0.16, 2.571,
ifelse(symmetry_mean <= 0.18, 3.141,
ifelse(symmetry_mean <= 0.20, 3.434, 4.583))),
radius_se_score = ifelse(radius_se <= 0.22, 0.0808,
ifelse(radius_se <= 0.33, 1.287,
ifelse(radius_se <= 0.44, 1.842, 4.648))),
texture_se_score = ifelse(texture_se <= 0.90, -0.895,
ifelse(texture_se <= 1.20, -1.469,
ifelse(texture_se <= 1.50, -1.929, -3.777))),
fractal_dimension_se_score = ifelse(fractal_dimension_se <= 0.002, -0.585,
ifelse(fractal_dimension_se <= 0.003, -1.004,
ifelse(fractal_dimension_se <= 0.004, -1.433, -6.443))))
# _score로 끝나는 모든 변수들의 합을 계산하여 score라는 새로운 열을 생성
score_03_vars <- grep("_score$", names(score_3_data), value = TRUE)
score_03_data <- score_03_data %>% mutate(score = rowSums(.[score_03_vars]))
group_B <- score_3_data$score[score_3_data$diagnosis == "B"]
group_M <- score_3_data$score[score_3_data$diagnosis == "M"]
# KS 통계량 계산
ks_result_03 <- ks.test(group_B, group_M)
# KS 통계량 출력
print(ks_result_03$statistic)
# 누적 B/M 구성비 분포 그래프 그리기
ggplot() +
stat_ecdf(data = data.frame(score = group_B, group = "B"), aes(score, colour = group)) +
stat_ecdf(data = data.frame(score = group_M, group = "M"), aes(score, colour = group)) +
labs(x = "Score", y = "Cumulative Proportion",
title = "Cumulative Distribution Plot for Score",
subtitle = "Blue: Group B, Red: Group M")
# 'B'와 'M' 진단 그룹의 실제 라벨 생성
actual <- ifelse(score_3_data$diagnosis == "B", 0, 1)
# 예측 객체 생성
pred <- prediction(score_3_data$score, actual)
# ROC 곡선 계산
roc_obj <- performance(pred, "tpr", "fpr")
# AUROC 값 계산
auc_obj <- performance(pred, "auc")
# AUROC 값 출력
print(auc_obj@y.values[[1]])
# 'B'와 'M' 진단 그룹의 실제 라벨 생성
actual <- ifelse(score_03_data$diagnosis == "B", 0, 1)
# 예측 객체 생성
pred <- prediction(score_03_data$score, actual)
# ROC 곡선 계산
roc_obj <- performance(pred, "tpr", "fpr")
# AUROC 값 계산
auc_obj <- performance(pred, "auc")
# AUROC 값 출력
print(auc_obj@y.values[[1]])
# 각 변수에 대해 주어진 범위에 따라 클래스와 점수를 부여
score_01_data <- selected_data %>%
mutate(radius_mean_score = ifelse(radius_mean <= 10, 1,
ifelse(radius_mean <= 13, 2,
ifelse(radius_mean <= 16, 3, 4))),
texture_mean_score = ifelse(texture_mean <= 16, 1,
ifelse(texture_mean <= 19, 2,
ifelse(texture_mean <= 22, 20.35, 27.7))),
smoothness_mean_score = ifelse(smoothness_mean <= 0.08, 1,
ifelse(smoothness_mean <= 0.09, 2,
ifelse(smoothness_mean <= 0.12, 3, 4))),
compactness_mean_score = ifelse(compactness_mean <= 0.06, 1,
ifelse(compactness_mean <= 0.09, 2,
ifelse(compactness_mean <= 16, 3, 4))),
symmetry_mean_score = ifelse(symmetry_mean <= 0.16, 1,
ifelse(symmetry_mean <= 0.18, 2,
ifelse(symmetry_mean <= 0.20, 3, 4))),
radius_se_score = ifelse(radius_se <= 0.22, 1,
ifelse(radius_se <= 0.33, 2,
ifelse(radius_se <= 0.44, 3, 4))),
texture_se_score = ifelse(texture_se <= 0.90, 1,
ifelse(texture_se <= 1.20, 2,
ifelse(texture_se <= 1.50, 3, 4))),
fractal_dimension_se_score = ifelse(fractal_dimension_se <= 0.002, 1,
ifelse(fractal_dimension_se <= 0.003, 2,
ifelse(fractal_dimension_se <= 0.004, 3, 4))))
# _score로 끝나는 모든 변수들의 합을 계산하여 score라는 새로운 열을 생성
score_01_vars <- grep("_score$", names(score_01_data), value = TRUE)
score_01_data <- score_01_data %>% mutate(score = rowSums(.[score_01_vars]))
group_B <- score_01_data$score[score_01_data$diagnosis == "B"]
group_M <- score_01_data$score[score_01_data$diagnosis == "M"]
# KS 통계량 계산
ks_result_01 <- ks.test(group_B, group_M)
# KS 통계량 출력
print(ks_result_01$statistic)
# 누적 B/M 구성비 분포 그래프 그리기
ggplot() +
stat_ecdf(data = data.frame(score = group_B, group = "B"), aes(score, colour = group)) +
stat_ecdf(data = data.frame(score = group_M, group = "M"), aes(score, colour = group)) +
labs(x = "Score", y = "Cumulative Proportion",
title = "Cumulative Distribution Plot for Score",
subtitle = "Blue: Group B, Red: Group M")
# 'B'와 'M' 진단 그룹의 실제 라벨 생성
actual <- ifelse(score_01_data$diagnosis == "B", 0, 1)
# 예측 객체 생성
pred <- prediction(score_01_data$score, actual)
# ROC 곡선 계산
roc_obj <- performance(pred, "tpr", "fpr")
# AUROC 값 계산
auc_obj <- performance(pred, "auc")
# AUROC 값 출력
print(auc_obj@y.values[[1]])
# 각 변수에 대해 주어진 범위에 따라 클래스와 점수를 부여
score_03_data <- selected_data %>%
mutate(radius_mean_score = ifelse(radius_mean <= 10, 9.5,
ifelse(radius_mean <= 13, 12.7,
ifelse(radius_mean <= 16, 14.6, 21.8))),
texture_mean_score = ifelse(texture_mean <= 16, 5.8,
ifelse(texture_mean <= 19, 7.6,
ifelse(texture_mean <= 22, 8.8, 12.0))),
smoothness_mean_score = ifelse(smoothness_mean <= 0.08, 5.4,
ifelse(smoothness_mean <= 0.09, 7.1,
ifelse(smoothness_mean <= 0.12, 7.9, 10.6))),
compactness_mean_score = ifelse(compactness_mean <= 0.06, 1.1,
ifelse(compactness_mean <= 0.09, 2.1,
ifelse(compactness_mean <= 16, 3.0, 5.8))),
symmetry_mean_score = ifelse(symmetry_mean <= 0.16, 2.5,
ifelse(symmetry_mean <= 0.18, 3.1,
ifelse(symmetry_mean <= 0.20, 3.4, 4.5))),
radius_se_score = ifelse(radius_se <= 0.22, 0.8,
ifelse(radius_se <= 0.33, 1.2,
ifelse(radius_se <= 0.44, 1.8, 4.6))),
texture_se_score = ifelse(texture_se <= 0.90, -0.8,
ifelse(texture_se <= 1.20, -1.4,
ifelse(texture_se <= 1.50, -1.9, -3.7))),
fractal_dimension_se_score = ifelse(fractal_dimension_se <= 0.002, -0.5,
ifelse(fractal_dimension_se <= 0.003, -1.0,
ifelse(fractal_dimension_se <= 0.004, -1.4, -6.4))))
# _score로 끝나는 모든 변수들의 합을 계산하여 score라는 새로운 열을 생성
score_03_vars <- grep("_score$", names(score_03_data), value = TRUE)
score_03_data <- score_03_data %>% mutate(score = rowSums(.[score_03_vars]))
group_B <- score_03_data$score[score_03_data$diagnosis == "B"]
group_M <- score_03_data$score[score_03_data$diagnosis == "M"]
# KS 통계량 계산
ks_result_03 <- ks.test(group_B, group_M)
# KS 통계량 출력
print(ks_result_03$statistic)
# 누적 B/M 구성비 분포 그래프 그리기
ggplot() +
stat_ecdf(data = data.frame(score = group_B, group = "B"), aes(score, colour = group)) +
stat_ecdf(data = data.frame(score = group_M, group = "M"), aes(score, colour = group)) +
labs(x = "Score", y = "Cumulative Proportion",
title = "Cumulative Distribution Plot for Score",
subtitle = "Blue: Group B, Red: Group M")
# 'B'와 'M' 진단 그룹의 실제 라벨 생성
actual <- ifelse(score_03_data$diagnosis == "B", 0, 1)
# 예측 객체 생성
pred <- prediction(score_03_data$score, actual)
# ROC 곡선 계산
roc_obj <- performance(pred, "tpr", "fpr")
# AUROC 값 계산
auc_obj <- performance(pred, "auc")
# AUROC 값 출력
print(auc_obj@y.values[[1]])
